class e{constructor(e=!1){this.map={},this.suspended=1==e}addListener(r,n,i={}){if("string"!=typeof r&&!(r instanceof String)&&r!==e.ANY_EVENT)throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");if("function"!=typeof n)throw new TypeError("The callback must be a function.");const s=new t(r,this,n,i);return this.map[r]||(this.map[r]=[]),i.prepend?this.map[r].unshift(s):this.map[r].push(s),s}addOneTimeListener(e,t,r={}){r.remaining=1,this.addListener(e,t,r)}static get ANY_EVENT(){return Symbol.for("Any event")}hasListener(t){return void 0===t?!!(this.map[e.ANY_EVENT]&&this.map[e.ANY_EVENT].length>0)||Object.entries(this.map).some(([,e])=>e.length>0):!!(this.map[t]&&this.map[t].length>0)}get eventNames(){return Object.keys(this.map)}getListeners(e){return this.map[e]||[]}suspend(e){this.getListeners(e).forEach(e=>{e.suspended=!0})}unsuspend(e){this.getListeners(e).forEach(e=>{e.suspended=!1})}getListenerCount(e){return this.getListeners(e).length}emit(t,...r){if("string"!=typeof t&&!(t instanceof String))throw new TypeError("The 'event' parameter must be a string.");if(this.suspended)return;let n=[],i=this.map[e.ANY_EVENT]||[];return this.map[t]&&(i=i.concat(this.map[t])),i.forEach(e=>{if(e.suspended)return;let t=[...r];Array.isArray(e.arguments)&&(t=t.concat(e.arguments)),e.remaining>0&&(n.push(e.callback.apply(e.context,t)),e.count++),--e.remaining<1&&e.remove()}),n}removeListener(e,t,r={}){if(void 0===e)return void(this.map={});if(!this.map[e])return;let n=this.map[e].filter(e=>t&&e.callback!==t||r.remaining&&r.remaining!==e.remaining||r.context&&r.context!==e.context);n.length?this.map[e]=n:delete this.map[e]}async waitFor(e,t={}){return t.duration=parseInt(t.duration),(isNaN(t.duration)||t.duration<=0)&&(t.duration=1/0),new Promise((r,n)=>{let i,s=this.addListener(e,()=>{clearTimeout(i),r()},{remaining:1});t.duration!==1/0&&(i=setTimeout(()=>{s.remove(),n("The duration expired before the event was emitted.")},t.duration))})}get eventCount(){return Object.keys(this.map).length}}class t{constructor(t,r,n,i={}){if("string"!=typeof t&&!(t instanceof String)&&t!==e.ANY_EVENT)throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");if(!r)throw new ReferenceError("The 'target' parameter is mandatory.");if("function"!=typeof n)throw new TypeError("The 'callback' must be a function.");void 0===i.arguments||Array.isArray(i.arguments)||(i.arguments=[i.arguments]),(i=Object.assign({context:r,remaining:1/0,arguments:void 0,duration:1/0},i)).duration!==1/0&&setTimeout(()=>this.remove(),i.duration),this.event=t,this.target=r,this.callback=n,this.context=i.context,this.remaining=parseInt(i.remaining)>=1?parseInt(i.remaining):1/0,this.count=0,this.arguments=i.arguments,this.suspended=!1}remove(){this.target.removeListener(this.event,this.callback,{context:this.context,remaining:this.remaining})}}
/*!
 * isArrayBuffer v1.0.1
 * https://github.com/fengyuanchen/is-array-buffer
 *
 * Copyright (c) 2015-2018 Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2018-04-01T07:19:08.136Z
 */var r="function"==typeof ArrayBuffer,n=Object.prototype.toString;const i=require("string-to-arraybuffer");class s extends e{constructor(){super(),this.buffer="",this.listeners={},this.connectionId=null,this.port=null}async open(e={}){if(e.port)this.port=e.port,delete e.port;else{let e=await s.getDevices();this.port=e[e.length-1].path}return e=Object.assign({bitrate:57600},e),new Promise(t=>{chrome.serial.connect(this.port,e,e=>{this.connectionId=e.connectionId,this.listeners.onDataReceived=this.onDataReceived.bind(this),chrome.serial.onReceive.addListener(this.listeners.onDataReceived),this.listeners.onError=this.onError.bind(this),chrome.serial.onReceiveError.addListener(this.listeners.onError),e.port=this.port,t(e)})})}static async getDevices(e=!1){return new Promise(t=>{chrome.serial.getDevices(r=>{let n=r;e||(n=r.filter(e=>/usb|acm|^com/i.test(e.path))),t(n)})})}static async getSerialConnections(){return new Promise(e=>chrome.serial.getConnections(e))}async getConnectionInfo(){return this.connectionId?new Promise(e=>{chrome.serial.getInfo(this.connectionId,t=>e(t))}):null}async send(e){let t;var s;return s=e,t=r&&(s instanceof ArrayBuffer||"[object ArrayBuffer]"===n.call(s))?e:i(e+"\n"),new Promise(e=>{chrome.serial.send(this.connectionId,t,t=>e(t))})}async sendInstruction(e,t){if(!e)return Promise.reject("You must provide a command.");let r=e;return t&&(r+="="+parseInt(t)),r+="\n",this.send(r)}onDataReceived(e){let t=s.ab2str(e.data).split("\n");t[0]=this.buffer+t[0],this.buffer=t.pop(),t.forEach(e=>{const[t,r]=e.split("=");this.emit(t,r)})}onError(e){this.emit("error",{connectionId:e.connectionId,code:e.error}),this.close()}async close(){return new Promise(e=>{chrome.serial.onReceive.removeListener(this.listeners.onDataReceived),this.listeners.onDataReceived=void 0,chrome.serial.onReceiveError.removeListener(this.listeners.onError),this.listeners.onError=void 0,this.port=null,chrome.serial.disconnect(this.connectionId,e),this.connectionId=null})}static ab2str(e,t){return null==t&&(t="utf8"),Buffer.from(e).toString(t)}}export{s as Nward};
//# sourceMappingURL=nward.esm.min.js.map
