class e{constructor(e=!1){this.map={},this.suspended=1==e}addListener(n,r,i={}){if("string"!=typeof n&&!(n instanceof String)&&n!==e.ANY_EVENT)throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");if("function"!=typeof r)throw new TypeError("The callback must be a function.");const s=new t(n,this,r,i);return this.map[n]||(this.map[n]=[]),i.prepend?this.map[n].unshift(s):this.map[n].push(s),s}addOneTimeListener(e,t,n={}){n.remaining=1,this.addListener(e,t,n)}static get ANY_EVENT(){return Symbol.for("Any event")}hasListener(t){return void 0===t?!!(this.map[e.ANY_EVENT]&&this.map[e.ANY_EVENT].length>0)||Object.entries(this.map).some(([,e])=>e.length>0):!!(this.map[t]&&this.map[t].length>0)}get eventNames(){return Object.keys(this.map)}getListeners(e){return this.map[e]||[]}suspend(e){this.getListeners(e).forEach(e=>{e.suspended=!0})}unsuspend(e){this.getListeners(e).forEach(e=>{e.suspended=!1})}getListenerCount(e){return this.getListeners(e).length}emit(t,...n){if("string"!=typeof t&&!(t instanceof String))throw new TypeError("The 'event' parameter must be a string.");if(this.suspended)return;let r=[],i=this.map[e.ANY_EVENT]||[];return this.map[t]&&(i=i.concat(this.map[t])),i.forEach(e=>{if(e.suspended)return;let t=[...n];Array.isArray(e.arguments)&&(t=t.concat(e.arguments)),e.remaining>0&&(r.push(e.callback.apply(e.context,t)),e.count++),--e.remaining<1&&e.remove()}),r}removeListener(e,t,n={}){if(void 0===e)return void(this.map={});if(!this.map[e])return;let r=this.map[e].filter(e=>t&&e.callback!==t||n.remaining&&n.remaining!==e.remaining||n.context&&n.context!==e.context);r.length?this.map[e]=r:delete this.map[e]}async waitFor(e,t={}){return t.duration=parseInt(t.duration),(isNaN(t.duration)||t.duration<=0)&&(t.duration=1/0),new Promise((n,r)=>{let i,s=this.addListener(e,()=>{clearTimeout(i),n()},{remaining:1});t.duration!==1/0&&(i=setTimeout(()=>{s.remove(),r("The duration expired before the event was emitted.")},t.duration))})}get eventCount(){return Object.keys(this.map).length}}class t{constructor(t,n,r,i={}){if("string"!=typeof t&&!(t instanceof String)&&t!==e.ANY_EVENT)throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");if(!n)throw new ReferenceError("The 'target' parameter is mandatory.");if("function"!=typeof r)throw new TypeError("The 'callback' must be a function.");void 0===i.arguments||Array.isArray(i.arguments)||(i.arguments=[i.arguments]),(i=Object.assign({context:n,remaining:1/0,arguments:void 0,duration:1/0},i)).duration!==1/0&&setTimeout(()=>this.remove(),i.duration),this.event=t,this.target=n,this.callback=r,this.context=i.context,this.remaining=parseInt(i.remaining)>=1?parseInt(i.remaining):1/0,this.count=0,this.arguments=i.arguments,this.suspended=!1}remove(){this.target.removeListener(this.event,this.callback,{context:this.context,remaining:this.remaining})}}
/*!
 * isArrayBuffer v1.0.1
 * https://github.com/fengyuanchen/is-array-buffer
 *
 * Copyright (c) 2015-2018 Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2018-04-01T07:19:08.136Z
 */var n="function"==typeof ArrayBuffer,r=Object.prototype.toString;const i=require("string-to-arraybuffer"),s=require("arraybuffer-to-string");class o extends e{constructor(){super(),this.buffer="",this.listeners={},this.connectionId=null,this.port=null}async connect(e={}){if(e.port)this.port=e.port,delete e.port;else{let e=await o.getDevices();this.port=e[e.length-1].path}return e=Object.assign({bitrate:115200},e),new Promise(t=>{chrome.serial.connect(this.port,e,e=>{this.connectionId=e.connectionId,this.listeners.onDataReceived=this.onDataReceived.bind(this),chrome.serial.onReceive.addListener(this.listeners.onDataReceived),this.listeners.onError=this.onError.bind(this),chrome.serial.onReceiveError.addListener(this.listeners.onError),e.port=this.port,t(e)})})}static async getDevices(e=!1){return new Promise(t=>{chrome.serial.getDevices(n=>{let r=n;e||(r=n.filter(e=>/usb|acm|^com/i.test(e.path))),t(r)})})}static async getSerialConnections(){return new Promise(e=>chrome.serial.getConnections(e))}async getConnectionInfo(){return this.connectionId?new Promise(e=>{chrome.serial.getInfo(this.connectionId,t=>e(t))}):null}async send(e,t=!1){let s;var o;return o=e,n&&(o instanceof ArrayBuffer||"[object ArrayBuffer]"===r.call(o))?s=e:(t&&(e+="\n"),s=i(e)),new Promise(e=>{chrome.serial.send(this.connectionId,s,t=>e(t))})}async sendMessage(e,t){if(!e)return Promise.reject("You must provide a command.");let n=e;return t&&(n+="="+t),n+="\n",this.send(n)}onDataReceived(e){let t=s(e.data).split("\n");t[0]=this.buffer+t[0],this.buffer=t.pop(),t.forEach(e=>{const[t,n]=e.split("=");this.emit(t,n)})}onError(e){this.emit("error",{connectionId:e.connectionId,code:e.error}),this.disconnect()}async disconnect(){return new Promise(e=>{chrome.serial.onReceive.removeListener(this.listeners.onDataReceived),this.listeners.onDataReceived=void 0,chrome.serial.onReceiveError.removeListener(this.listeners.onError),this.listeners.onError=void 0,this.port=null,chrome.serial.disconnect(this.connectionId,e),this.connectionId=null})}get connected(){return!!this.connectionId}}export{o as Nward};
//# sourceMappingURL=nward.esm.min.js.map
