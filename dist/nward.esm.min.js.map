{"version":3,"file":"nward.esm.min.js","sources":["../node_modules/djipevents/dist/djipevents.esm.min.js","../node_modules/is-array-buffer/dist/is-array-buffer.esm.js","../src/nward.js"],"sourcesContent":["class e{constructor(e=!1){this.map={},this.suspended=1==e}addListener(n,r,i={}){if(\"string\"!=typeof n&&!(n instanceof String)&&n!==e.ANY_EVENT)throw new TypeError(\"The 'event' parameter must be a string or EventEmitter.ANY_EVENT.\");if(\"function\"!=typeof r)throw new TypeError(\"The callback must be a function.\");const s=new t(n,this,r,i);return this.map[n]||(this.map[n]=[]),i.prepend?this.map[n].unshift(s):this.map[n].push(s),s}addOneTimeListener(e,t,n={}){n.remaining=1,this.addListener(e,t,n)}static get ANY_EVENT(){return Symbol.for(\"Any event\")}hasListener(t){return void 0===t?!!(this.map[e.ANY_EVENT]&&this.map[e.ANY_EVENT].length>0)||Object.entries(this.map).some(([,e])=>e.length>0):!!(this.map[t]&&this.map[t].length>0)}get eventNames(){return Object.keys(this.map)}getListeners(e){return this.map[e]||[]}suspend(e){this.getListeners(e).forEach(e=>{e.suspended=!0})}unsuspend(e){this.getListeners(e).forEach(e=>{e.suspended=!1})}getListenerCount(e){return this.getListeners(e).length}emit(t,...n){if(\"string\"!=typeof t&&!(t instanceof String))throw new TypeError(\"The 'event' parameter must be a string.\");if(this.suspended)return;let r=[],i=this.map[e.ANY_EVENT]||[];return this.map[t]&&(i=i.concat(this.map[t])),i.forEach(e=>{if(e.suspended)return;let t=[...n];Array.isArray(e.arguments)&&(t=t.concat(e.arguments)),e.remaining>0&&(r.push(e.callback.apply(e.context,t)),e.count++),--e.remaining<1&&e.remove()}),r}removeListener(e,t,n={}){if(void 0===e)return void(this.map={});if(!this.map[e])return;let r=this.map[e].filter(e=>t&&e.callback!==t||n.remaining&&n.remaining!==e.remaining||n.context&&n.context!==e.context);r.length?this.map[e]=r:delete this.map[e]}async waitFor(e,t={}){return t.duration=parseInt(t.duration),(isNaN(t.duration)||t.duration<=0)&&(t.duration=1/0),new Promise((n,r)=>{let i,s=this.addListener(e,()=>{clearTimeout(i),n()},{remaining:1});t.duration!==1/0&&(i=setTimeout(()=>{s.remove(),r(\"The duration expired before the event was emitted.\")},t.duration))})}get eventCount(){return Object.keys(this.map).length}}class t{constructor(t,n,r,i={}){if(\"string\"!=typeof t&&!(t instanceof String)&&t!==e.ANY_EVENT)throw new TypeError(\"The 'event' parameter must be a string or EventEmitter.ANY_EVENT.\");if(!n)throw new ReferenceError(\"The 'target' parameter is mandatory.\");if(\"function\"!=typeof r)throw new TypeError(\"The 'callback' must be a function.\");void 0===i.arguments||Array.isArray(i.arguments)||(i.arguments=[i.arguments]),(i=Object.assign({context:n,remaining:1/0,arguments:void 0,duration:1/0},i)).duration!==1/0&&setTimeout(()=>this.remove(),i.duration),this.event=t,this.target=n,this.callback=r,this.context=i.context,this.remaining=parseInt(i.remaining)>=1?parseInt(i.remaining):1/0,this.count=0,this.arguments=i.arguments,this.suspended=!1}remove(){this.target.removeListener(this.event,this.callback,{context:this.context,remaining:this.remaining})}}export{e as EventEmitter,t as Listener};\n//# sourceMappingURL=djipevents.esm.min.js.map\n","/*!\n * isArrayBuffer v1.0.1\n * https://github.com/fengyuanchen/is-array-buffer\n *\n * Copyright (c) 2015-2018 Chen Fengyuan\n * Released under the MIT license\n *\n * Date: 2018-04-01T07:19:08.136Z\n */\n\nvar hasArrayBuffer = typeof ArrayBuffer === 'function';\nvar toString = Object.prototype.toString;\n\n/**\n * Check if the given value is an ArrayBuffer.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is an ArrayBuffer, else `false`.\n * @example\n * isArrayBuffer(new ArrayBuffer())\n * // => true\n * isArrayBuffer([])\n * // => false\n */\n\nfunction isArrayBuffer(value) {\n  return hasArrayBuffer && (value instanceof ArrayBuffer || toString.call(value) === '[object ArrayBuffer]');\n}\n\nexport default isArrayBuffer;\n","const str2ab = require(\"string-to-arraybuffer\");\n\nimport {EventEmitter} from \"../node_modules/djipevents/dist/djipevents.esm.min.js\";\nimport isArrayBuffer from \"../node_modules/is-array-buffer/dist/is-array-buffer.esm.js\";\n\nexport class Nward extends EventEmitter{\n\n  constructor() {\n    super();\n    this.buffer = \"\";\n    this.listeners = {};\n    this.connectionId = null;\n    this.port = null;\n  }\n\n  /**\n   * Tries to open a serial connection to the Arduino-compatible device hooked up to the specified\n   * port. If no port is specified, it tries to connect to the last port in the list obtained by\n   * calling [getDevices()]{@link Nward#getDevices()}.\n   *\n   * This is an asynchronous operation. When it succeeds, it returns a promise fulfilled with a\n   * [ConnectionInfo()]{@link https://developer.chrome.com/apps/serial#type-ConnectionInfo} object\n   * providing information about the established connection.\n   *\n   * @param {Object} [options={}]\n   * @param {string} [options.port] The port to connect to. On Windows, it will look like this:\n   * `COM3`. On Linux and macOS, it will tippically look like this: `/dev/cu.usbmodem2101`.\n   * @param {string} [options.bitrate=57600] The requested bitrate of the connection to be opened.\n   * For compatibility with the widest range of hardware, this number should match one of\n   * commonly-available bitrates such as:\n   *\n   *  * 110\n   *  * 300\n   *  * 1200\n   *  * 2400\n   *  * 4800\n   *  * 9600\n   *  * 14400\n   *  * 19200\n   *  * 38400\n   *  * 57600 (default)\n   *  * 115200\n   *\n   * @returns {Promise<Object>}\n   */\n  async open(options = {}) {\n\n    if (options.port) {\n      this.port = options.port;\n      delete options.port;\n    } else {\n      let devices = await Nward.getDevices();\n      this.port = devices[devices.length - 1].path;\n    }\n\n    let defaults = {\n      bitrate: 57600,\n    };\n\n    options = Object.assign(defaults, options);\n\n    return new Promise(resolve => {\n\n      chrome.serial.connect(this.port, options, info => {\n        this.connectionId = info.connectionId;\n        this.listeners.onDataReceived = this.onDataReceived.bind(this);\n        chrome.serial.onReceive.addListener(this.listeners.onDataReceived);\n        this.listeners.onError = this.onError.bind(this);\n        chrome.serial.onReceiveError.addListener(this.listeners.onError);\n        info.port = this.port;\n        resolve(info);\n      });\n\n    });\n\n  }\n\n  /**\n   * Device\n   *\n   * @typedef {Object} Nward~Device\n   * @property {string} path - Indicates whether the Courage component is present.\n   * @property {string} vendorId - Indicates whether the Power component is present.\n   * @property {string} productId - Indicates whether the Wisdom component is present.\n   * @property {string} displayName - Indicates whether the Wisdom component is present.\n   */\n\n  /**\n   * Returns a list of sserial devices likely to be Arduino-compatible. This list will always\n   * include all Arduino-compatible devices but, depending on the platform, may also nclude other\n   * serial devices as well. If the `all` parameter is set to true, it will systematically return\n   * all serial devices.\n   *\n   * @param {boolean} [all=false] Whether to return all serial devices or only Arduino-compatible\n   * devices.\n   * @returns {Promise<array>} An array of Nward~Device objects describing the devices\n   * found.\n   */\n  static async getDevices(all = false) {\n\n    return new Promise(resolve => {\n\n      chrome.serial.getDevices(devices => {\n\n        let found = devices;\n\n        if (!all) found = devices.filter(device => /usb|acm|^com/i.test(device.path));\n        resolve(found);\n\n      });\n\n    });\n\n  }\n\n  /**\n   * Returns a promise fulfilled with an array of currently opened serial port connections owned by\n   * the application.\n   *\n   * @returns {Promise<array>}\n   */\n  static async getSerialConnections() {\n    return new Promise(resolve => chrome.serial.getConnections(resolve));\n  }\n\n  /**\n   *\n   * @returns {Promise<unknown>}\n   */\n  async getConnectionInfo() {\n\n    if (!this.connectionId) return null;\n\n    return new Promise(resolve => {\n      chrome.serial.getInfo(this.connectionId, info => resolve(info));\n    });\n\n  }\n\n  /**\n   * Sends the specified data to the Arduino. The data can be a `string` or an `ArrayBuffer`. If\n   * it's a string, a newline will be appended at the end.\n   *\n   * @param {string|ArrayBuffer} data The data to send to the Arduino\n   * @returns {Promise<unknown>}\n   */\n  async send(data) {\n\n    let ab;\n\n    if (isArrayBuffer(data)) {\n      ab = data;\n    } else {\n      ab = str2ab(data + \"\\n\");\n    }\n\n    return new Promise(resolve => {\n      chrome.serial.send(this.connectionId, ab, info => resolve(info));\n    });\n\n  }\n\n  async sendInstruction(command, value) {\n\n    if (!command) return Promise.reject(\"You must provide a command.\");\n\n    let instruction = command;\n    if (value) instruction += \"=\" + parseInt(value);\n    instruction += \"\\n\";\n\n    return this.send(instruction);\n\n  }\n\n  onDataReceived(info) {\n\n    let lines = Nward.ab2str(info.data).split(\"\\n\");\n    lines[0] = this.buffer + lines[0];\n    this.buffer = lines.pop();\n\n    lines.forEach(line => {\n      const [type, value] = line.split(\"=\");\n      this.emit(type, value);\n    });\n\n  }\n\n  onError(info) {\n    this.emit(\"error\", {connectionId: info.connectionId, code: info.error});\n    this.close();\n  }\n\n  async close() {\n\n    return new Promise(resolve => {\n\n      chrome.serial.onReceive.removeListener(this.listeners.onDataReceived);\n      this.listeners.onDataReceived = undefined;\n      chrome.serial.onReceiveError.removeListener(this.listeners.onError);\n      this.listeners.onError = undefined;\n      this.port = null;\n\n      chrome.serial.disconnect(this.connectionId, resolve);\n      this.connectionId = null;\n\n    });\n\n  }\n\n  static ab2str(buffer, encoding) {\n    if (encoding == null) encoding = \"utf8\";\n    return Buffer.from(buffer).toString(encoding);\n  }\n\n}\n"],"names":["e","[object Object]","this","map","suspended","n","r","i","String","ANY_EVENT","TypeError","s","t","prepend","unshift","push","remaining","addListener","Symbol","for","length","Object","entries","some","eventNames","keys","getListeners","forEach","concat","Array","isArray","arguments","callback","apply","context","count","remove","filter","duration","parseInt","isNaN","Promise","clearTimeout","setTimeout","eventCount","ReferenceError","assign","event","target","removeListener","hasArrayBuffer","ArrayBuffer","toString","prototype","str2ab","require","Nward","EventEmitter","super","buffer","listeners","connectionId","port","options","devices","getDevices","path","bitrate","resolve","chrome","serial","connect","info","onDataReceived","bind","onReceive","onError","onReceiveError","all","found","device","test","getConnections","getInfo","data","ab","value","call","send","command","reject","instruction","lines","ab2str","split","pop","line","type","emit","code","error","close","undefined","disconnect","encoding","Buffer","from"],"mappings":"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"}